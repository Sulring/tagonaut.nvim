Write a Lua plugin Vaura for nvim that has tollowing mappable commands: 

To read TOML values use "toml" package from luarocks-
For sql use lsqlite3


config_name <- is a short hash of a workspace path + the name of directory. Workspace it a directory where nvim was started (important!).
Example: 
workspace path: /home/username/dev/project
config_name -> hash("/home/username/dev/project") .. "_project"
and so the path of config file would be: "~/.vaura/" .. hash("/home/username/dev/project") .. "_project.toml".

# Command: Vaura config
`Vaura config` opens a "~/.vaura/" .. config_name .. ".toml". If not exists, it creates an empty one with the following template:


```toml
system = ""
api_key = ""
model = ""
summary_model = "flash"
top_p = 1.0
temperature = 1.0
username = "User"
bot_name = "Assistant"

[content]
conversation = "default"
code_command = ""
include_code = true
include_history = 0
summarize = 0
include_tags = []

[models]
sonnet = "anthropic/claude-3.5-sonnet:beta"
gpt = "openai/chatgpt-4o-latest"
llama_large = "meta-llama/llama-3.1-405b-instruct"
llama_medium = "meta-llama/llama-3.1-70b-instruct"
online = "perplexity/llama-3.1-sonar-huge-128k-online"
flash = "google/gemini-flash-1.5"
pro = "google/gemini-pro-1.5"
```

Explanation of variables:
*system*
Sets system config variable to argument. 

*model*
Sets which model from the list of "models" to use

*include_code*
A bool, sets if code should be included

*code_command*
Shell command which's to be executed when user uses message command, It provides the content that's included as $CODE.

*include_history*
Sets number of entries to include in the message history. 0 for no mesasages. -1 for all messages. History is separated by "conversation" scope/

*summarize* 
Sets the number of included history messages to summarize.
-1 -> all included messages are summarized.
0 -> all included messages are raw unsummarized.
1 -> 1 oldest message is included as a summary, the rest raw unsummarized.
n -> n oldest messages are included summarized, the rest - raw unsummarized. 
Number of summarized message is less or equals number of include history message. If it's greater, it's clamped to the value of included history messages.

*top_p*
Sets top_p variable (check that it's 0.0-1.0)

*temperature*
Sets temperature variable. (check that it's 0.0 - 2.0)

*include_tags*
An array that sets which tagged messages are to be included.

# Command: Vaura message
`Vaura message`
Opens a file "~/.vaura/" .. config_name .. ".md". 
When user closes the file, the plugin uses its content to send request, equivalent of this shell request: 

```
curl https://openrouter.ai/api/v1/chat/completions \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $CONFIG_API_KEY" \
  -d '{
  "model": "$CONFIG_MODEL",
  "messages": [
    {"role": "system", "content": "$CONFIG_SYSTEM \n\n $CODE \n\n #CONVERSATION HISTORY SUMMARY:\n $SUMMARY"},
    ...$INCLUDED_MESSAGES,
    {"role": "user", "content": "$MESSAGE"}
  ]
  
}' 
```

CONFIG_API_KEY is a api_key variable set in config.toml
same for CONFIG_SYSTEM
CONFIG_MODEL is models[model] entry from config.toml
INCLUDED_MESSAGES are tagged_messages + history messages included into the message in raw form. 
If summarize set in config to -1 or >0, then first it sends a request with history messages that need to be summarized:

```
curl https://openrouter.ai/api/v1/chat/completions \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $CONFIG_API_KEY" \
  -d '{
  "model": "$CONFIG_SUMMARY_MODEL",
  "messages": [
    {"role": "system", "content": "You're a summarizer who summarizes conversations provided by user. Your summaries are detailed and contain all important information about conversation. You don't write any introductions. You don't write any outros. You only provide the summary of conversation."},
    {"role": "...", "message": "..."},
    {},
    ...further messages to summarize
    ]
  
}' 
```
Tagged messages are excluded from summarizations. Tagged messages may overlap with history messages. It's ok.
The result from this request is then included as $SUMMARY variable. Don't forget that messages are scoped by workspace and conversation.

The user message and response are written to sqlite3 database ~/.vaura/db/db.db in form of schema:
id (autoincrement, bigint), name (uses username and bot_name), role, message, message_date (date + time, use appropriate data type), workspace, conversation, tag (default Null)

Then it opens a special vertical split buffer  with content of the response (the buffer should use markdown highlighting).


# Command: Vaura tag <num> <tag_name>
Sets a tag to a message by relative number. 0 is the latest message. 1 - a message before the latest, etc. tag_name is a string that serves as tag. Tagged messages ARE NOT scoped. They're available everywhere.



